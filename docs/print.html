<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Celeri UI Docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Celeri UI Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p><img src="https://github.com/brendanjmeade/celeri_ui/actions/workflows/publish-pages.yml/badge.svg" alt="test workflow" /></p>
<p>These are the docs for <a href="https://brendanjmeade.github.io/celeri_ui/">Celeri UI</a> - the front end for setting up kinematic earthquake cycle models, for use with <a href="https://github.com/brendanjmeade/celeri">celeri</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-celeri-ui"><a class="header" href="#using-celeri-ui">Using Celeri UI</a></h1>
<p>[TODO] Write up user guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">Development</a></h1>
<p><a href="https://gitpod.io/#https://github.com/brendanjmeade/celeri_ui">Open a GitPod Workspace</a></p>
<h2 id="pre-requisites"><a class="header" href="#pre-requisites">Pre-requisites</a></h2>
<p>Celeri UI is built using a few well-established tools.</p>
<p>The following are the foundational tools for working in the codebase - you'd need at least a basic understanding of these to be able to contribute to the code:</p>
<ul>
<li><a href="https://git-scm.com/">Git</a> - this is the source code management toolset.</li>
<li><a href="https://www.typescriptlang.org/">Typescript</a> - this is the programming language we use.</li>
<li><a href="https://reactjs.org/docs/getting-started.html">React</a> - a library that makes it easier to generate &amp; interact with the html in the page, by creating a set of components that manage their own display.</li>
<li><a href="https://redux.js.org/introduction/getting-started">Redux</a> - a library that handles state management, and makes it easier to have deterministic &amp; testable state changes.</li>
<li><a href="https://mochajs.org/">Mocha</a> - a library to enable testing in Javascript/Typescript in a fairly isolated fashion.</li>
<li><a href="https://nodejs.org/en/">NodeJs</a> - this is used to manage the packages we utilize, and execute the tests &amp; build processes.</li>
</ul>
<p>If you need to make adjustments to how the map is drawn, or the items displayed on top of the map, you will need to work with <a href="https://docs.mapbox.com/mapbox-gl-js/example/">MapBox</a> &amp; <a href="https://github.com/mapbox/mapbox-gl-draw">MapBox Draw</a> - however, it might be enough to look at things as you go.</p>
<p>The development server &amp; build pipeline are based on <a href="https://vitejs.dev/">Vite</a>, and the actual build is deployed with github actions, which run the automated tests &amp; a code quality check, before building and publishing the built version. We are using <a href="https://rust-lang.github.io/mdBook/">mdBook</a> for the docs.</p>
<p>We recommend using <a href="https://gitpod.io">GitPod</a> for development, rather than setting up a local development environment, since it handles all the complexity of that for you. You can open a workspace by using the link above.</p>
<h3 id="set-up-optional"><a class="header" href="#set-up-optional">Set Up (Optional)</a></h3>
<p>If you wish to set up a local development enviroment, you will need to install NodeJS on your machine, clone the git repository, and run <code>npm install</code> within it.</p>
<h2 id="development-command-line-commands"><a class="header" href="#development-command-line-commands">Development Command Line Commands</a></h2>
<ul>
<li>If you are running in a local environment, or if you changed the dependencies (in the package.json file), you will need to run <code>npm install</code> to ensure all the correct packages are installed.</li>
<li>To start the development server, you can run <code>npm run dev</code> in the command line.</li>
<li>To run the tests, run <code>npm run test</code> in the commad line</li>
<li>To start the documentation server (so you can view the docs, or your changes to them in real time), run <code>npm run docs:dev</code></li>
<li>While developing, you will need to use <code>git commit</code>, <code>git pull</code> &amp; <code>git push</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="codebase-overview"><a class="header" href="#codebase-overview">Codebase Overview</a></h1>
<p>When you first look at a new codebase it can be a bit confusing, so here we'll go over the major areas of the codebase to help you understand what's what:</p>
<ul>
<li>
<p><code>./.github/workflows</code> - this folder contains the test &amp; build workflows that are run by github. The <code>test.yml</code> &amp; <code>codeql-analysis.yml</code> workflows are run on every commit to either main or a Pull Request targeting main - these run the tests and ensure the code is in a good place. The <code>publish-pages.yml</code> runs on every commit to main, but only if both the tests &amp; code quality analysis pass, and it deploys a new build to <a href="https://brendanjmeade.github.io/celeri_ui/">github.io</a>. It can be useful to look at the results of the workflows - which can be found here: https://github.com/brendanjmeade/celeri_ui/actions</p>
</li>
<li>
<p><code>./.husky</code> - this folder contains a simple command that runs before you can commit - it ensures the code is properly formatted, and runs all the tests locally.</p>
</li>
<li>
<p><code>./docs/src</code> - this folder contains the documentation sources - mdBook have a nice <a href="https://rust-lang.github.io/mdBook/guide/creating.html">overview of how the folder is structured</a>, as well as an <a href="https://rust-lang.github.io/mdBook/format/markdown.html">overview of markdown</a> - the format used for writing the docs themselves.</p>
</li>
<li>
<p><code>./mocha/tests</code> - this folder contains the automated tests - tests that don't involve visible components have the <code>.spec.ts</code> extension, while those that do involve visible components have the <code>spec.tsx</code> extension</p>
</li>
<li>
<p><code>./public</code> - this folder contains static assets published alongside the app - for example the icon</p>
</li>
<li>
<p><code>./src</code> - this is where the bulk of the app's code is located</p>
<ul>
<li><code>Components</code> - this is where we define the various visible components used by the UI - such as the various inspector panels, the top bar &amp; the file explorer
<ul>
<li><code>Map</code> - this is where we define the Celeri Map - this is the most complex component in the app, and is used to wrap the MapBox api's and provide an interface for the kinds of data we care about.</li>
</ul>
</li>
<li><code>Selectors</code> - this is where we define more complex selectors - functions that take in some state and create a derived value, and remember the result in case the state hasn't changed - see <a href="https://redux-toolkit.js.org/api/createSelector">createSelector</a> for an overview</li>
<li><code>State</code> - this is where we define and store the main state structures &amp; the actions that can transform the state. Each sub-directory contains a separate "domain", where we can define the types we care about and the operations available to change it. For example - the "Block" directory defines what a block looks like in terms of the available properties, and provides operations for loading new block data (for example, from a file), creating blocks, editing blocks, moving blocks, and deleting them.</li>
<li><code>Utilities</code> - this is where we have utility functions/classes that don't particularly fit anywhere else. For example, the interface for handling the file system or the parsers for different file types (the various CSV, .json &amp; .msh files).</li>
<li><code>main.tsx</code> - this file just loads the app, it is unlikely to need to change</li>
<li><code>index.css</code> - this file defines the styles we use - notice that it uses <code>@tailwind</code> to load the styles from <a href="https://tailwindcss.com/docs">TailwindCSS</a></li>
<li><code>App.tsx</code> - this is the core of the App - this file coordinates the global state &amp; various top-level components</li>
</ul>
</li>
<li>
<p><code>./index.html</code> - this is the main HTML file for the UI. You are unlikely to need to make changes here, but it is where things like the title of the tab are set</p>
</li>
<li>
<p><code>./package.json</code> - this is where we define the dependencies, development dependencies &amp; runnable scripts for the develoment of celeri ui. The scripts are run using <code>npm run {script name}</code> - for example, <code>npm run test</code> runs the test script.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-cycle"><a class="header" href="#development-cycle">Development Cycle</a></h1>
<p>As a rule, the following process is recommended for making changes:</p>
<ul>
<li>
<p>Start by determining whether it is an automatically testible change. The main criteria for this are the degree to which it relies on interaction with the map display itself, and the variability of the UI. To provide some examples:</p>
<ul>
<li>State transformations - such as the "Merge Vertices" operation - are easily testible, since we can create a function that takes in a set of parameters, and outputs a result deterministically based entirely on those initial parameters.</li>
<li>Most utility functions (so long as they don't require specific browser functions, or those functions can be abstracted away) - such as the parsing of <code>.msh</code> files - are also testible, since they are also entirely deterministic functions.</li>
<li>Some UI elements - such as the File Explorer &amp; Editable Item components - have a simple, clear interface, and simple state transformations, making them easy to test. However, this is more of a judgement call. For example, I could probably set up a test for the BlockPanel (the inspector for blocks), but decided against it because it is more of an aggregator of functionality, and most of the interaction with it will either involve things that have been tested (such as the Editable Item), or things that cannot be easily tested (such as the Map component). On the flip side, some UI elements felt trivial enough for me to not bother setting up a test (such as the SelectionModeDetails component) - because they basically function as a very simple display.</li>
</ul>
</li>
<li>
<p>If it's a testible change, you want to follow this process:</p>
<ul>
<li>First, start by adding a test case (or adjusting existing test cases) to match the expected behaviour. Ideally you would do this "one requirement at a time", but sometimes you may need to batch things (for example, if there are a number of existing cases that need to be adjusted)</li>
<li>Then run the test, to see if it fails. If it doesn't fail, since we didn't implement the behaviour, it means that either the test isn't testing the correct behaviour or the behaviour already exists - investigate that situation, and if the test isn't checking the correct thing adjust it.</li>
<li>Once the test has failed, go in and implement an initial, simple version that passes the tests.</li>
<li>Refactor/adjust the simple version to match the requirements better, ensuring it keeps passing the test.</li>
<li>Repeat the process with the next requirement. This way you ensure that you keep the code as simple as possible while still meeting the requirements, since you focus on providing the simplest solution you can each time, and refactoring/cleaning up as you go along.</li>
</ul>
</li>
<li>
<p>If it's not a testible change, make sure to have the application open to your local development server (if you are using gitpod, it should have been started automatically, and you can open it by opening the "Remote Explorer" panel on the left hand side, hovering over port 3000, and clicking the "Open Browser" button (the globe))</p>
<ul>
<li>You want to first get to the point where the expected changes would be apparent, essentially working through the workflow until it is impossible. This will help you clarify exactly what you are looking to change</li>
<li>Start by making the simplest change to unblock the next step of the workflow</li>
<li>Once that next step is working, refactor/adjust the code</li>
<li>walk through the the workflow again to get to the next point where it's impossible or broken, and repeat the process, until the full flow works</li>
<li>Go back to the top of this process for any alternative workflow/paths you can think of to get into the situation, to try and find edge cases or other ways it may break. Because these changes aren't autmatically tested, you need to manually work through things to try and find if anything broke during the process - this is why you want to make as much of the code base automatically tested, since it helps reduce accidentaly breakages.</li>
</ul>
</li>
</ul>
<p>For more information on this test-driven development approach, I'd recommend looking at the <a href="https://www.youtube.com/c/ContinuousDelivery">Continious Delivery</a> youtube channel, specifically this playlist: https://www.youtube.com/playlist?list=PLwLLcwQlnXByqD3a13UPeT4SMhc3rdZ8q</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-workflow-example"><a class="header" href="#development-workflow-example">Development Workflow Example</a></h1>
<p>For this example, I'll be walking through resolving the following bug: https://github.com/brendanjmeade/celeri_ui/issues/40
In case you want to "follow along", check out the following commit: <code>d379b87f459a28667ea1f3785ce34c9eb831dd5a</code>
You can also look at the <code>development-example</code> branch.</p>
<p>First up is ensuring you have an up to date code base. I tend to like to create a new gitpod workspace for each issue I'm working on, since it ensures things are fresh and up to date, but if you are working locally you can just checkout <code>main</code> &amp; <code>git pull</code> to ensure it's up to date.</p>
<p>Then, we want to explore the issue abit more - we need to reproduce it, and try to see where it breaks/causes issues. In this case - I took the following steps:</p>
<ul>
<li>Opening a segment file</li>
<li>Select a single segment connects to two other segments, one on each end, and delete it <img src="./SelectSingleSegment.png" alt="Select a Segment" />
<ul>
<li>this looks like it behaved correctly, neither of the vertices were deleted because they are still connected to other segments.</li>
</ul>
</li>
<li>Select one of the formerly adjacent segments, which now has one vertex that doesn't connect to any other segments, and delete it <img src="./SelectAdjacentSegment.png" alt="Select Adjacent Segment" />
<ul>
<li>this also seems to behave correctly, the dangling vertex was deleted, but the connect vertex wasn't</li>
</ul>
</li>
<li>Select one of the segments further one step away from the edge, and delete it <img src="./SelectOneStepAway.png" alt="Select one step away" /></li>
<li>The Select the "floating" segment and delete it <img src="./SelectFloatingSegment.png" alt="Select Floating Segment" />
<ul>
<li>This again works correctly - both the vertices connected to that segment are deleted.</li>
</ul>
</li>
<li>All of this suggests, to me, that the issue comes from having multiple segments deleted at once, so lets try that</li>
<li>Switch to the Segment edit mode, and Lasso-select 3 connected segments, one of which has only one connected segment, then delete them <img src="./LassoSelect.png" alt="Lasso Select" />
<ul>
<li>Here we finally replicated the issue - the segments are deleted, but the vertices seem to all remain - including the one that was originally "dangling" <img src="./IssueFound.png" alt="Issue Found" /></li>
</ul>
</li>
</ul>
<p>This suggests that the issue is that the segment deletion logic doesn't know how to handle multiple segments being deleted at once while also getting rid of their connected vertices. So lets take a look at the relevant tests. Because we are dealing with segment state, we should go take a look at the <a href="https://github.com/brendanjmeade/celeri_ui/blob/d379b87f459a28667ea1f3785ce34c9eb831dd5a/mocha/tests/SegmentState.spec.tsx">mocha/tests/SegmentState.spec.tsx</a></p>
<p>Looking through the code, I found 3 test cases that seem relevant - one starting on line 74, one on line 88 &amp; one on line 103. Interestingly, it looks like the only difference between the first two is that the latter one also verifies that there are no vertices remaining. Since they don't test different scenarios, I'll delete the one at 74. So now we have two existing tests: <code>can delete a segment</code> &amp; <code>can delete a segment sharing a vertex with another segment</code>.
Both of those behaviours remain appropriate for our current scenario, so lets create a new test, after the <code>can delete a segment sharing a vertex with another segment</code>.
I'll call it <code>can delete multiple segments &amp; their associated vertices</code>:</p>
<pre><code class="language-typescript">it('Can delete multiple segments &amp; their associated vertices', () =&gt; {
	/* Here I'm setting up the initial state
      I want to have 3 segments connected in a line
    */
	const firstSegment = SegmentReducer(initialState, {
		type: 'createSegmet',
		payload: {
			start: { lon: 0, lat: 0 },
			end: { lon: 1, lat: 1 }
		}
	})
	const secondSegment = SegmentReducer(firstSegment, {
		type: 'createSegmet',
		payload: {
			start: { lon: 1, lat: 1 },
			end: { lon: 2, lat: 2 }
		}
	})
	const thirdSegment = SegmentReducer(secondSegment, {
		type: 'createSegmet',
		payload: {
			start: { lon: 2, lat: 2 },
			end: { lon: 3, lat: 3 }
		}
	})

	// Now we run the delete operation, and tell it to delete the first two segments
	const state = SegmentReducer(thirdSegment, {
		type: 'deleteSegment',
		payload: { index: [0, 1] }
	})

	// Investigating the resulting state, we expect to only have one segment left, and only two vertices
	expect(state.segments).to.have.length(1)
	expect(Object.keys(state.vertecies)).to.have.length(2)

	// The segment we have left should be the third segment we created
	expect(state.segments[0].start).to.equal(2)
	expect(state.segments[0].end).to.equal(3)
	// And the vertices we have left should match the vertices used by that segment
	expect(state.vertecies[2].lat).equal(2)
	expect(state.vertecies[3].lat).equal(3)
})
</code></pre>
<p>Then I run <code>npm run test</code> in the console, and check the result. Strangely, this new test still seems to pass! That tells us that the issue is either with the code calling the segment deletion function, or that our test doesn't correctly isolate the factors causing this bug.
Since our manual tests did suggest that this should correctly isolate the bug, let's take a look at how the segment deletion process gets triggered first.</p>
<p>My first instinct is to look in <a href="https://github.com/brendanjmeade/celeri_ui/blob/d379b87f459a28667ea1f3785ce34c9eb831dd5a/src/Components/SegmentsPanel.tsx">src/Components/SegmentsPanel.tsx</a>, since I know the Segments Panel is where we delete segments. However, looking through there I don't see a specific location where deletion is called - but I do see that <code>EditableItem</code> has a <code>deletable</code> tag, so I look at the function it calls - <code>setSegmentData</code>. That get's passed in by the parent component, so we can search for where the segments panel is used - <a href="https://github.com/brendanjmeade/celeri_ui/blob/d379b87f459a28667ea1f3785ce34c9eb831dd5a/src/Components/Inspector.tsx">src/Components/Inspector.tsx</a> on line 315.</p>
<p>Here, we look for <code>setSegmentData</code>, and find that it has the following code:</p>
<pre><code class="language-typescript">;(index, data): void =&gt; {
	if (data) {
		dispatch(editSegmentData({ indices: index, data }))
	} else {
		dispatch(deleteSegment({ index }))
	}
}
</code></pre>
<p>So now we know that the dispatch looks correct - when no data is passed, this is treated as a delete operation, in which case we pass the indices of the segments we want to delete...</p>
<p>This takes us back to the drawing board - it seems like the issue isn't with the data coming in to our deletion operation, and it looks like our test suggests that the delete operation itself is working correctly. So lets see if maybe it's actually an issue with the map not refreshing to display the correct information?</p>
<p>To test this - we'll first repeat the steps we took before, so we get back to the step where we reproduced the issue:</p>
<p><img src="./IssueFound.png" alt="Issue Found" /></p>
<p>Then, we force a refresh of the vertex display on the map, by swapping to Vertex edit mode - at which point our mystery vertices disapper!</p>
<p><img src="./ToEditMode.png" alt="To Edit Mode" /></p>
<p>This means it's not triggering an update of the vertices displayed. For most things in the maps, a re-render is triggered by the object representing the state being replaced - so this might be a situation where we are accidentally mutating an object in place rather than actually replacing it during the state change.</p>
<p>At this point, I'm not sure if this is the case, but it's the best theory I've got so we're going to try and investigate it. Lets go back out our test in <code>SegmentState.spec.tsx</code>.</p>
<p>We'll start by adding something to verify that our vertex object is actually being replaced:</p>
<pre><code class="language-typescript">// Added these next two lines
expect(state.vertecies).to.not.equal(thirdSegment.vertecies)
expect(state.vertexDictionary).to.not.equal(thirdSegment.vertexDictionary)

expect(state.segments).to.have.length(1)
expect(Object.keys(state.vertecies)).to.have.length(2)

expect(state.segments[0].start).to.equal(2)
expect(state.segments[0].end).to.equal(3)
expect(state.vertecies[2].lat).equal(2)
expect(state.vertecies[3].lat).equal(3)
</code></pre>
<p>and then we run it with <code>npm run test</code> - and it seems to pass. So the issue doesn't show up here, yet.</p>
<p>On the one hand, this does narrow things down a bit - it loos like this happens between the point where the vertices are changed, and the point where they are actually drawn on the map.</p>
<p>So now is the time to open the debugger, and look at things as they happen! In the browser, open the dev tools (either by tapping <code>f12</code> on the keyboard, or right clicking somewhere that isn't the map and selecting "Inspect"), then navigate to the "Sources" tab.
<img src="./DebugSourcesTab.png" alt="Sources Tab" /></p>
<p>Next, we need to find the file where we update drawn points - <code>/src/Utilities/SetupPointSources.tsx</code> - in the file hierarchy on the left - it'll be under <code>workspace/celeri_ui/src/Utilities</code>
<img src="./DebugFS.png" alt="Debug File Hierarchy" /></p>
<p>Once we have the file open, we can set break points - points that will stop the execution of the code and let us see what's going on in real time - by clicking to the left of the line numbers at the points we want to inspect. In this case - we want to see when the vertices are updated, and it looks like that is hidden behind the if statement at line 38 - so we'll put the break point right after that:
<img src="./Breakpoint.png" alt="Breakpoint" /></p>
<p>Now, let's lasso-select a few segments again - you'll notice that the moment we switch to Lasso Selection mode, or to Segment edit mode (if you weren't in that mode before), the breakpoint triggers. This is too early for us to get information, so let's click the breakpoint again to remove it, and click the play button or <code>f8</code> to resume.
<img src="./PlayButton.png" alt="Play Button" /></p>
<p>First, we need to select some segments, with the lasso select tool. Then we'll re-add the breakpoint at the same place, and then we'll click the delete button in the segment panel.
This does seem to trigger our breakpoint - which means it should have the up to date information, but when we resume (by clicking play or <code>f8</code>), we see the issue persists...</p>
<p>So let's try to manually refresh - if we do so by changing the edit mode, it seems things happen as expected as well. But if we just try to toggle the vertex display, we see that it doesn't seem to trigger our breakpoint! And the vertices don't get hidden.
<img src="./VertexDisplay.png" alt="Vertex Display" /></p>
<p>Once I noticed that, I realized that we actually allow editing vertices while in Segment edit mode - so we actually have vertices passing in to the drawn points (points that can be moved) in addition to the vertex points, but we probably aren't updating those!</p>
<p>So - let's move to see what's happening where those points are set! First, lets get rid of the breakpoint (by clicking on it), and then we'll go in and find where the the drawn points are set - <a href="https://github.com/brendanjmeade/celeri_ui/blob/d379b87f459a28667ea1f3785ce34c9eb831dd5a/src/Utilities/SetupDrawnPointSource.tsx">src/Utilities/SetupDrawnPointSource.tsx</a>, open it up in the browser dev tools and set a breakpoint at line 37/38 - right at the start of the function. Then - we can start experimenting with adjusting the edit mode &amp; the display, to try to find out what happens.</p>
<p>First, I set the edit mode to vertex, which triggered the function, and it went into the "EditMode.Vertex" case, where it sets the data for drawing the vertices. Then, I turned off the Vertex display, which did the same thing, but passes it an empty array of vertices - so the points disappears. I turned the vertex display back on, then swapped to Segment edit mode. This time, it went to the default case, and didn't set the drawn points at all! Meaning that so long as we are in Segment edit mode, the drawn vertices don't get updated. I tried deleting segments with the Lasso again, and saw the same things - it goes to the default case, which does nothing.</p>
<p>So let's try and fix that - we want to make a case for segment edit mode. Now - I think we would likely still want the ability to select &amp; move vertices while in segment edit mode, since vertices &amp; segments are so tightly coupled. The main difference between these modes should be the Lasso. So - we'll just make the Segment edit mode apply the same case as the Vertex edit mode in there <code>src/Utilities/SetupDrawnPointSource.tsx</code>:</p>
<pre><code class="language-typescript">switch (editMode) {
		case EditMode.Segments: //added this line here
		case EditMode.Vertex: {
			setDrawnPointSource({
				color: vertexSettings.color,
				radius: vertexSettings.radius,
				selectedColor: vertexSettings.activeColor,
				selectedRadius: vertexSettings.activeRadius,
				points: vertexSettings.hide
					? []
					: (Object.keys(segments.vertecies)
							.map(v =&gt; {
								const index = Number.parseInt(v, 10)
								const vert = segments.vertecies[index]
								if (vert) {
									return {
										longitude: vert.lon,
										latitude: vert.lat,
										index
									}
								}
								return false
							})
							.filter(v =&gt; !!v) as unknown as {
							longitude: number
							latitude: number
							index: number
					  }[]),
				update: (index, vertex) =&gt; {
					dispatch(moveVertex({ index, vertex }))
				},
				select: index =&gt; {
					select.select('vertex', index)
				}
			})

			break
		}
</code></pre>
<p>To see how this works/if this works, we should refresh the page, reload the segment file, and then try to lasso-select &amp; delete the segments. This time, it seems to work!</p>
<p>While playing around with this, however - I noticed a curious thing. Sometimes, when I lasso select some segments, it seems to also change the selected Vertices on the map - but not select them in the vertices tab. (note - I made regular vertices tiny and selected vertices huge to highlight the effect)
<img src="./MysteryVertexSelection.png" alt="Mystery Vertex Selection" /></p>
<p>So - lets look at that. The displayed selections on the map get set in <a href="https://github.com/brendanjmeade/celeri_ui/blob/d379b87f459a28667ea1f3785ce34c9eb831dd5a/src/App.tsx">src/App</a> - where it sets the map selections (line 418). Here we have what seems to be the source of the issue: the lasso selection is automatically set as the selection for "draw" - the points that can be moved on the map.</p>
<pre><code class="language-typescript">selections={{
					segments: selectedSegment,
					blocks: selectedBlock,
					velocities: selectedVelocity,
					vertices: selectedVertex,
					draw: lassoSelection
				}}
</code></pre>
<p>If we add a condition there to exclude the segment edit mode, then we should avoid selecting those situations!</p>
<pre><code class="language-typescript">selections={{
					segments: selectedSegment,
					blocks: selectedBlock,
					velocities: selectedVelocity,
					vertices: selectedVertex,
					draw: editMode === EditMode.Segments ? undefined :lassoSelection
				}}
</code></pre>
<p>For now we'll ignore the squiggly line under "draw" - that just means there is a type issue, which we'll fix if this solves the main issue we're seeing. Let's see if that same issue persists - I'll try selecting the same segments that caused the issue before. And it seems like it works!
<img src="./NoLongerMystery.png" alt="No Longer Mystery" /></p>
<p>So now, let's just resolve that type issue. The "selections" property of <code>CeleryMap</code> currently has a type of <code>Record&lt;string, number[]&gt;</code> - let's adjust that to <code>Record&lt;string, number[] | undefined&gt;</code>. We can do that by going to <a href="https://github.com/brendanjmeade/celeri_ui/blob/d379b87f459a28667ea1f3785ce34c9eb831dd5a/src/Components/Map/CeleriMap.tsx">src/Components/Map/CeleriMap.tsx</a>, going to the <code>MapProperties</code> interface (line 48), and adjusting the selctions property.</p>
<p>However, since we've made that change, it is worth checking whether that leads to any type issues - this is one of the benefits of using typescript! It can catch issue that might arise from our changes. A good way to do that, if you are running in gitpod, is to use the <code>tsc</code> command in the console. In this case, I got the following result:</p>
<pre><code>gitpod /workspace/celeri_ui (development-example) $ tsc
src/Components/Map/MapArrows.ts:248:6 - error TS2322: Type 'number[] | undefined' is not assignable to type 'number[]'.
  Type 'undefined' is not assignable to type 'number[]'.

248      updatedInternalSelections[sourcename] = selections[sourcename]
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/Components/Map/MapDrawnPoints.ts:113:51 - error TS2322: Type 'number[] | undefined' is not assignable to type 'number[]'.
  Type 'undefined' is not assignable to type 'number[]'.

113      internalSelections: { ...internalSelections, draw: selections.draw }
                                                      ~~~~

src/Components/Map/MapLineSegments.ts:237:6 - error TS2322: Type 'number[] | undefined' is not assignable to type 'number[]'.
  Type 'undefined' is not assignable to type 'number[]'.

237      updatedInternalSelections[sourcename] = selections[sourcename]
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/Components/Map/MapPoints.ts:170:6 - error TS2322: Type 'number[] | undefined' is not assignable to type 'number[]'.
  Type 'undefined' is not assignable to type 'number[]'.

170      updatedInternalSelections[sourcename] = selections[sourcename]
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Found 4 errors in 4 files.

Errors  Files
     1  src/Components/Map/MapArrows.ts:248
     1  src/Components/Map/MapDrawnPoints.ts:113
     1  src/Components/Map/MapLineSegments.ts:237
     1  src/Components/Map/MapPoints.ts:170
		 ```

Looks like we forgot to adjust the `internalSelections` property of the map's state to match! The map has some internal states that duplicate properties, as a way to help it detect when things changed. So let's make that adjustment - you'll find it in the `MapState` interface (line 26 of `/src/Components/Map/CeleriMap.tsx`) - and we just need to change it to match the type of the `selections` property.

Let's run `tsc` again to confirm that it resolved our issue - and it should return nothing, which means the type issues were resolved!

So now we're basically done, we just have to run the tests locally, commit &amp; push the result!

Once you do that, it is important to wait for the tests &amp; code quality pass to run, and see whether it fails for whatever reason. You can do so here: [Github Actions](https://github.com/brendanjmeade/celeri_ui/actions) - in this case, the tests did fail, and looking through the details of the failure I found this:
![Test Failure](./TestFailureDetails.png)

Interestingly, running `npm run test` locally doesn't produce that result, but it's still worth resolving. So we go to the two locations mentioned in the error `src/Components/Map/MapLineSegments.ts` line 81 &amp; `src/Components/Map/MapPolygonSources.ts` line 56, and replace the logical or `||` with the nullish operator `??`, like so:
```typescript
selected: selections[source.name]?.includes(line.index) || false
becomes
selected: selections[source.name]?.includes(line.index) ?? false
```

and then we run the tests, commit, push, and keep an eye on the github actions again.
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
